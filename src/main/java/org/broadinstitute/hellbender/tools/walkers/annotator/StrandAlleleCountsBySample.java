package org.broadinstitute.hellbender.tools.walkers.annotator;

import htsjdk.variant.variantcontext.Allele;
import htsjdk.variant.variantcontext.Genotype;
import htsjdk.variant.variantcontext.GenotypeBuilder;
import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.vcf.VCFFormatHeaderLine;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.broadinstitute.hellbender.engine.ReferenceContext;
import org.broadinstitute.hellbender.tools.walkers.annotator.interfaces.AnnotatorCompatible;
import org.broadinstitute.hellbender.tools.walkers.annotator.interfaces.GenotypeAnnotation;
import org.broadinstitute.hellbender.utils.genotyper.MostLikelyAllele;
import org.broadinstitute.hellbender.utils.genotyper.PerReadAlleleLikelihoodMap;
import org.broadinstitute.hellbender.utils.read.GATKRead;
import org.broadinstitute.hellbender.utils.variant.GATKVCFConstants;
import org.broadinstitute.hellbender.utils.variant.GATKVCFHeaderLines;

import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * Number of forward and reverse reads that support each allele
 *
 * <p>The StrandAlleleCountsBySample annotation produces read counts per allele (including (REF) and per strand.  Note that, as with the <a href="https://www.broadinstitute.org/gatk/guide/tooldocs/org_broadinstitute_gatk_tools_walkers_annotator_DepthPerAlleleBySample.php">AD</a> annotation, the allele counts here should not be used to make assumptions about the called genotype.</p>
 *
 * <p>This annotation produces 2 values per allele at each site, corresponding to the number of reads that support the following (in that order):</p>
 * <ul>
 *     <li>the reference allele on the forward strand</li>
 *     <li>the reference allele on the reverse strand</li>
 *     <li>the first alternate allele on the forward strand</li>
 *     <li>the first alternate allele on the reverse strand</li>
 *     <li>the second alternate allele on the forward strand</li>
 *     <li><i>...etc</i></li>
 * </ul>
 *
 * <h3>Example</h3>
 * <pre>GT:AD:GQ:PL:SB:SAC       1/2:1,18,12:99:1022,326,382,537,0,487:1,0,4,8:1,0,3,15,4,8</pre>
 * <p>In this example, the reference allele is supported by 1 read on the forward strand, the first alternate allele is supported by 3 forward and 15 reverse reads, and the second alternate allele is supported by 4 forward and 8 reverse reads.</p>
 *
 * <h3>Caveats</h3>
 * <ul>
 *     <li>This annotation can only be generated by HaplotypeCaller (it will not work when called from VariantAnnotator).</li>
 * </ul>
 *
 * <h3>Related annotations</h3>
 * <ul>
 *     <li><b><a href="https://www.broadinstitute.org/gatk/guide/tooldocs/org_broadinstitute_gatk_tools_walkers_annotator_DepthPerAlleleBySample.php">DepthPerAlleleBySample</a></b> displays the number of reads supporting each allele, without stratifying by strand.</li>
 * </ul>
 */


public class StrandAlleleCountsBySample extends GenotypeAnnotation {
    private final static Logger logger = LogManager.getLogger(StrandAlleleCountsBySample.class);
    boolean[] warningsLogged = new boolean[4];

    @Override
    public void annotate(final RefMetaDataTracker tracker,
                         final AnnotatorCompatible walker,
                         final ReferenceContext ref,
                         final AlignmentContext stratifiedContext,
                         final VariantContext vc,
                         final Genotype g,
                         final GenotypeBuilder gb,
                         final PerReadAlleleLikelihoodMap alleleLikelihoodMap) {

        if ( !AnnotationUtils.isAppropriateInput(walker, alleleLikelihoodMap, g, warningsLogged, logger) ) {
            return;
        }

        gb.attribute(GATKVCFConstants.STRAND_COUNT_BY_SAMPLE_KEY, getStrandCounts(Collections.singletonMap(g.getSampleName(), alleleLikelihoodMap), vc));
    }

    @Override
    public List<String> getKeyNames() { return Collections.singletonList(GATKVCFConstants.STRAND_COUNT_BY_SAMPLE_KEY); }

    @Override
    public List<VCFFormatHeaderLine> getDescriptions() {
        return Collections.singletonList(GATKVCFHeaderLines.getFormatLine(getKeyNames().get(0)));
    }

    /**
     * This method was inspired by (copied from) StrandBiasTest.getContingencyTable().  Unlike getContingencyTable, it
     * returns values for all alleles rather than only reference and the most likely allele.  Since this is not useful
     * for StrandBias calculations, it's here and it skips the Nx2 table format used in that method
     */
    private int[] getStrandCounts( final Map<String, PerReadAlleleLikelihoodMap> stratifiedPerReadAlleleLikelihoodMap, final VariantContext vc) {
        if( stratifiedPerReadAlleleLikelihoodMap == null ) { throw new IllegalArgumentException("stratifiedPerReadAlleleLikelihoodMap cannot be null"); }
        if( vc == null ) { throw new IllegalArgumentException("input vc cannot be null"); }

        final int[] table = new int[vc.getNAlleles()*2];

        for (final PerReadAlleleLikelihoodMap maps : stratifiedPerReadAlleleLikelihoodMap.values() ) {
            for (final Map.Entry<GATKRead,Map<Allele,Double>> el : maps.getLikelihoodReadMap().entrySet()) {
                final MostLikelyAllele mostLikelyAllele = PerReadAlleleLikelihoodMap.getMostLikelyAllele(el.getValue());
                final GATKRead read = el.getKey();
                if (mostLikelyAllele.isInformative()) {
                    updateTable(table, vc.getAlleleIndex(mostLikelyAllele.getAlleleIfInformative()), read);
                }
            }
        }

        return table;
    }

    private void updateTable(final int[] table, final int alleleIndex, final GATKRead read) {
        if (alleleIndex < 0 || (alleleIndex+1)*2 > table.length) {
            return;
        }
        final int offset = alleleIndex * 2;

        //Unstranded reads are not meaningful for this annotation, they can be found in the AD annotation
        if (!read.isStrandless()) {
            final boolean isFW = !read.getReadNegativeStrandFlag();
            table[offset + (isFW ? 0 : 1)]++;
        }
    }

}
